# pypy-tips
pypyのtipsです。


## algorithm
### 再帰
非再帰にしましょう。書けるなら非再帰です。

python/pypyには再帰上限があります。1000回以上再帰する可能性のある場合は
`sys.setlimitrecursion(10**6くらい?)`
としましょう。しないと`RE`です。グラフを扱うときはパスグラフを想像して上限を見積もると良いかも。

pypyの再帰は遅いです。代替？案として、以下のものがあります。
- pythonで提出する
  - (深めの)再帰はpythonの方が速いと言われています。
    - というか、pypyがおそすぎるだけです。
  - そもそもpythonも遅いので、再帰の中でガチャガチャやるコードはpythonにしても遅いと思われます。
- pypyjit
  - `import pypyjit; pypyjit.set_param('max_unroll_recursion=-1')`みたいな
  - pypyで提出するならつけましょう。
  - 基本、速くなります。
- ジェネレータ
  - 基本、速くなります。というか、遅くなった例を1件しか知りません。
  - 書き換えるのがやや面倒ですが、pypy -> c++と比べると圧倒的に楽です。

こどふぉでは
  - `sys.setlimitrecursion(2*10**5)`をすると`MLE`
  - しないと`RE`

となるため、再帰をしてはいけないことが自分の中で知られています。

## DataStructures
### 順序付き集合
pypyの標準ライブラリに順序付き集合はありません。代替手段を考えます。
- sortedcontainers
  - 言語アップデートを介して導入されました。
  - 速いかは分かってないです。若干遅そう？の感覚です。
- 平衡二分木
  - 強いです。平方分割木と比べると遅いケースが目立ちます。
    - Kiri氏の`PivotTree`は速い感覚があります。
      - 扱える値が非負整数に限られるという点はあります。
  - 列に対して区間反転ができる点は強いです。
- 平方分割木(tatyam木)
  - tatyam氏の`SortedSet/Multiset`です。
  - コードが短く、そして速いです。おそらく多くの人が使っていると思います。
- 座圧してBIT/セグ木
  - 座圧できるものに限られるので汎用性は低いです。
  - しかし、速いです。
  - 空間`Θ(U)`かかる点には注意です。
- BinaryTrie
  - 全体xor等ができます。
  - 実装のイメージがしやすく簡易かもしれないです。
- 32分木
  - neighbor queryに関しては最強です。
  - 空間`Θ(U)`、昇順`k`番目の値に`Θ(klogU)`かかる点には注意です。
- 亜種たち
  - van emde boas treeは実装次第ではとても遅いです。自分は速い実装が分かりません。
  - 追加/削除を`O(√U)`として`k`番目取得を`O(1)`でするようにすると、Moで強いです。

## Graph
基本的に隣接リスト`[[] for _ in range(|V|)]`で問題ないと思います。

## Math
`ModInt`はとにかく遅いです。使わない方が吉です。
