<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="../style.css">
<title>Library_py-py_tips-a</title>
</head>
<body>
### [Home](https://titanium-22.github.io/Library_py/)

_____

# pypy-tips

pypy の tips です。

## Algorithm

### 再帰
非再帰にしましょう。

python/pypy には再帰上限があります。1000 回以上再帰する可能性のある場合は
`sys.setlimitrecursion(10**6)`
などとしましょう。しないと`RE`です。パスグラフなんかを想像すると良いかも。

pypy の再帰は遅いです。代替？案として、以下のものがあります。
- 非再帰にする
	- 常勝！
- python で提出する
	- (深めの)再帰は python の方が速いと言われています。
    - というか、pypy がおそすぎるだけです。
      - 言語アップデートでマシになったかも？
	- そもそも python も遅いので、再帰の中でガチャガチャやるコードは python にしても遅いと思われます。
- `pypyjit`
	- `import pypyjit; pypyjit.set_param('max_unroll_recursion=-1')`みたいな
	- pypy で提出するならつけましょう。
	- 基本、速くなります。
	- メモリ使うのかな？
- [ジェネレータ](https://github.com/cheran-senthil/PyRival/blob/master/pyrival/misc/bootstrap.py)
	- 基本、速くなります。というか、遅くなった例を1件しか知りません。
    - `pypyjit` より速く、スタック非再帰よりは遅いイメージです。
	- 書き換えるのがやや面倒ですが、pypy -> c++ などと比べると圧倒的に楽です。
    - 関数の途中で `return` ができない点だけかな。 `if-else` で頑張ります。
	- なんで皆使ってないのか、正直謎に思ってます。

こどふぉでは
	- `sys.setlimitrecursion(2*10**5)`をすると`MLE`
	- しないと`RE`

となるため、再帰をしてはいけないことが知られています。

### メモ化
`functools.lru_cache` は内部で辞書を使っています。配列作って自力で書いた方が速い場合が多いです。

## DataStructures

### 順序付き集合

pypy の標準ライブラリに順序付き集合はありません。代替手段を考えます。

- `sortedcontainers`
	- 言語アップデートを介して導入されました。速いかは分かってないです。
- 平方分割木(tatyam木)
	- tatyam氏の [`SortedSet/Multiset`](https://github.com/tatyam-prime/SortedSet) です。
	- `O(√N)` ですが、コードが短くわりと速いです。おそらく多くの人が使っていると思います。
- 平衡二分木
	- 強いです。平方分割木と比べると遅いケースが目立ちます。
- B木
	- `k` 番目の値は遅めです。
	- `Set` はまずまずの速度です。
	- `Multiset` はまだ実装してません。
- BIT/セグ木
	- 空間 `Θ(U)` かかる点には注意です。
    - (BIT/セグ木に限らず、)座圧できるものに限られるので汎用性は低いです。
	- しかし、速いです。
- `BinaryTrie`
	- 全体 xor ができます。
	- 実装が簡易(かもしれない)です。
- 32分木
	- neighbor query に関しては最強です。
	- 空間 `Θ(U)` 、昇順 `k` 番目の値に `Θ(klogU)` かかる点には注意です。
- 亜種たち
	- van emde boas tree は実装次第ではとても遅いです。自分は速い実装が分かりません。
	- 追加 / 削除 を `O(√U)` として `k` 番目取得を `O(1)` でするようにすると、Mo で強いです。

## Graph
- 基本的に隣接リスト `[[] for _ in range(|V|)]` で問題ないと思います。
- グラフライブラリを作るのもよいでしょう。

## Math
- `ModInt` はとにかく遅いです。使わない方が吉です。


</body>
</html>
