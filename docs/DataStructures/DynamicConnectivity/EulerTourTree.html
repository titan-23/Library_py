<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="css/dark.css">
<title>EulerTourTree</title>
</head>
<body>
<hr /><h1><code>EulerTourTree</code></h1><hr /><h2>コード</h2><p><a href="https://github.com/titanium-22/Library_py/blob/main/DataStructures/DynamicConnectivity/EulerTourTree.py"><code>EulerTourTree</code></a></p><hr /><ul>
<li><code>Euler Tour Tree</code> です。森を管理します。部分木クエリの強さに定評があります。</li>
</ul><hr /><h2>解説</h2><p>解説を入れます。嘘があるかもです。勝手に混乱していってください。  </p><p>森です。各連結成分(木)は独立なのでそれごとに見ていきます。  </p><p>基本戦術はオイラーツアー(Euler tour technique)です。これはググってください。  </p><p>実は、ある木をオイラーツアーした列と、その木に対して 根の変更 / 辺の追加 / 辺の削除 をした木のオイラーツアーした列との差分は多くはありません。実際に紙に書くとよいでしょう。これをうまいこと管理します。  </p><p>列を平衡二分木で管理します。ここで、オイラーツアーの列はでは頂点ではなく辺の列とします。例えば、  </p><p><code>[0, 1, 0, 2, 0]</code>  </p><p>の頂点列は辺列  </p><p><code>[{0, 0}, {0, 1}, {1, 1}, {1, 0}, {0, 2}, {2, 2}, {2, 0}]</code>  </p><p>などとなります。  </p><p>また、補助データ構造として辺からノードのポインタをたどれる辞書を保持します。  </p><p>各処理の流れは以下のようになります。</p><ul>
<li>根の変更: <code>reroot(v)</code></li>
</ul><ul>
<li>辺 <code>{v, v}</code> の頂点の直前で <code>split</code> し、それを順に <code>A, B</code> とする</li>
</ul><ul>
<li><code>B</code> と <code>A</code> をこの順にマージする</li>
</ul><ul>
<li>辺の追加: <code>link(u, v)</code></li>
</ul><ul>
<li><code>reroot(u); reroot(v)</code></li>
</ul><ul>
<li><code>u, v</code> が属する木(のオイラーツアーした辺の列)をそれぞれ <code>E1, E2</code> とする</li>
</ul><ul>
<li><code>E1, [{u, v}], E2, [{v, u}]</code> をこの順にマージする</li>
</ul><ul>
<li>辺の削除: <code>cut(u, v)</code></li>
</ul><ul>
<li><code>reroot(v); reroot(u)</code></li>
</ul><ul>
<li><code>{u, v}, {v, u}</code> で <code>split</code> してできたものを順に <code>A, B, C</code> とする。ただし、 <code>{u, v}</code> は <code>A</code> に含まれ、 <code>{v, u}</code> は <code>C</code> に含まれる。</li>
</ul><ul>
<li><code>A</code> の末尾と <code>C</code> の先頭を削除し、 <code>A</code> と <code>C</code> をこの順にマージする </li>
</ul><ul>
<li>連結性判定: <code>same(u, v)</code></li>
</ul><ul>
<li><code>u, v</code> を <code>splay</code> して、 <code>u</code> の親が <code>None</code> じゃなければ連結。 <code>u == v</code> のときは別途処理をする。</li>
</ul><p>計算量は、オイラーツアーの管理と辺→ノードの管理に赤黒木を使えば最悪 <code>O(logN)</code> です。この実装ではsplay木とハッシュテーブルで管理するので償却 <code>O(logN)</code> +期待 <code>O(1)</code> です(もとのグラフの頂点数に対してオイラーツアーすると <code>(元の頂点数)+(辺数)*2?</code> の頂点ができるので、たしかに <code>O(元のグラフの頂点数)</code> ではありますが、定数倍がバカです)。  </p><p>オイラーツアーがあれば、部分木クエリは簡単に処理できます。</p><h2>仕様</h2><h4><code>ett = EulerTourTree(n_or_a: Union[int, Iterable[T]], op: Callable[[T, T], T]=lambda x, y: None, mapping: Callable[[F, T], T]=lambda x, y: None, composition: Callable[[F, F], F]=lambda x, y: None, e: T=None, id: F=None)</code></h4><ul>
<li><code>n / len(a)</code> 個の頂点からなる <code>EulerTourTree</code> を作成します。 <code>n_or_a</code> が <code>a</code> のとき、頂点の重みとみなします。</li>
</ul><h4><code>ett.build(G: List[List[int]]) -&gt; None</code></h4><ul>
<li>隣接リスト <code>G</code> をもとにして、 <code>ett</code> に辺を張り構築します。</li>
</ul><ul>
<li><code>O(N)</code> です。</li>
</ul><h4><code>ett.link(u: int, v: int) -&gt; None</code></h4><ul>
<li>辺 <code>{u, v}</code> を追加します。 <code>u</code> と <code>v</code> が同じ連結成分であってはいけません。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.cut(u: int, v: int) -&gt; None</code></h4><ul>
<li>辺 <code>{u, v}</code> を削除します。辺 <code>{u, v}</code> が存在してなければいけません。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.merge(u: int, v: int) -&gt; bool</code></h4><ul>
<li>頂点 <code>u</code> と <code>v</code> が同じ連結成分にいる場合はなにもせず <code>False</code> を返します。そうでない場合は辺 <code>{u, v}</code> を追加し <code>True</code> を返します。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.split(u: int, v: int) -&gt; bool</code></h4><ul>
<li>辺 <code>{u, v}</code> が存在しない場合はなにもせず <code>False</code> を返します。そうでない場合は辺 <code>{u, v}</code> を削除し <code>True</code> を返します。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.leader(v: int) -&gt; Node</code></h4><ul>
<li>頂点 <code>v</code> を含む木の代表元を返します。 <code>reroot</code> すると変わるので注意です。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.reroot(v: int) -&gt; None</code></h4><ul>
<li>頂点 <code>v</code> を含む木の根を <code>v</code> にします。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.same(u: int, v: int) -&gt; bool</code></h4><ul>
<li>頂点 <code>u</code> と <code>v</code> が同じ連結成分にいれば <code>True</code> を、そうでなければ <code>False</code> を返します。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.show() -&gt; None</code></h4><ul>
<li>デバッグ用です。</li>
</ul><h4><code>ett.subtree_apply(v: int, p: int, f: F) -&gt; None</code></h4><ul>
<li>頂点 <code>v</code> を根としたときの部分木に <code>f</code> を適用します。ただし、 <code>v</code> の親は <code>p</code> です。 <code>v</code> の親が存在しないときは <code>p=-1</code> として下さい。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.subtree_sum(v: int, p: int) -&gt; T</code></h4><ul>
<li>頂点 <code>v</code> を根としたときの部分木の総和を返します。ただし、 <code>v</code> の親は <code>p</code> です。 <code>v</code> の親が存在しないときは <code>p=-1</code> として下さい。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.group_count() -&gt; int</code></h4><ul>
<li>連結成分の個数を返します。</li>
</ul><ul>
<li><code>O(1)</code> です。</li>
</ul><h4><code>ett.get_vertex(v: int) / ett[v: int] -&gt; T</code></h4><ul>
<li>頂点 <code>v</code> の <code>key</code> を返します。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul><h4><code>ett.set_vertex(v: int, val: T) / ett[v: int] = val -&gt; None</code></h4><ul>
<li>頂点 <code>v</code> の <code>key</code> を <code>val</code> に更新します。</li>
</ul><ul>
<li><code>O(logN)</code> です。</li>
</ul>
</body>
</html>
