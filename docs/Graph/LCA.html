<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" type="text/css" href="https://github.com/titanium-22/Library_py/blob/main/docs/css/dark.css">
<title>LCA</title>
</head>
<body>
<hr /><h1><code>LCA</code></h1><hr /><h2>コード</h2><p><a href="https://github.com/titanium-22/Library_py/blob/main/Graph/LCA.py"><code>LCA.py</code></a></p><hr /><ul>
<li>オイラーツアーとスパーステーブルを用いて、構築 <code>O(NlogN)</code> クエリ <code>O(1)</code> を実現しています。</li>
</ul><ul>
<li>セグ木の方が速いと話題</li>
</ul><hr /><h2>仕様</h2><h4><code>tree = LCA(G: List[List[int]], root: int)</code></h4><ul>
<li>根が <code>root</code> の重み無し隣接リスト <code>G</code> で表されるグラフに対して <code>lca</code> を求めます。</li>
</ul><ul>
<li>初期化時に前計算を行っています。</li>
</ul><ul>
<li>計算量は時間・空間共に <code>O(NlogN)</code> です。</li>
</ul><h4><code>tree.lca(x: int, y: int) -&gt; int</code></h4><ul>
<li>頂点 <code>x</code> と頂点 <code>y</code> の <code>lca</code> を返します。</li>
</ul><ul>
<li><code>O(1)</code> 時間です。</li>
</ul><h4><code>tree.lca_mul(a: List[int]) -&gt; int</code></h4><ul>
<li>頂点集合 <code>a</code> の <code>lca</code> を求めます。</li>
</ul><ul>
<li><code>O(|A|)</code> 時間です。</li>
</ul><h4><code>tree.dist(x: int, y: int) -&gt; int</code></h4><ul>
<li>頂点 <code>x</code> と頂点 <code>y</code> の距離を返します。<strong>全ての辺のコストが1のときのみ使用できます。</strong></li>
</ul><ul>
<li><code>O(1)</code> 時間です。</li>
</ul><h2>使用例</h2><p>```python</p><p>n = int(input())</p><p>G = [[] for _ in range(n)]</p><p>for _ in range(n-1):</p><p>u, v = map(int, input().split())</p><p>u -= 1; v -= 1</p><p>G[u].append(v)</p><p>G[v].append(u)</p><p>tree = LCA(G, 0)  # O(nlogn)</p><p>q = int(input())</p><p>for _ in range(q):</p><p>x, y = map(int, input().split())</p><p>x -= 1; y -= 1</p><p>print(tree.lca(x, y))  # O(1)</p><p>```</p>
</body>
</html>
