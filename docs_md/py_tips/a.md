# `PyPy-tips`

`PyPy` の `tips` です。

## `Algorithm`

### 再帰

非再帰にしましょう。

`python/PyPy` には再帰上限があります。1000 回以上再帰する可能性のある場合は `sys.setlimitrecursion(10**6)` などとしましょう。しないと`RE`です。パスグラフなんかを想像すると良いかも。

`PyPy` の再帰は遅いです。代替？案として、以下のものがあります。

- 非再帰にする
  - 常勝！
  - 私はあまりしてません。
  - 再帰関数を書こうと思う -> 非再帰を書く にしたくはないという
  - 逆に、 `stack` 使って `while` 回したい -> よく見たら再帰 は別にある。
  - ライブラリでは、非再帰の方が速いので非再帰です。
- `python` で提出する
  - (深めの)再帰は `python` の方が速いと言われています。
    - というか、`PyPy` がおそすぎるだけです。
      - 言語アップデートでマシになったかも？
  - そもそも `python` も遅いので、再帰の中でガチャガチャやるコードは `python` にしても遅いと思われます。
  - 私は基本 `PyPy` です。
- `PyPyjit`
  - `import PyPyjit; PyPyjit.set_param('max_unroll_recursion=-1')`みたいな
  - `PyPy` で提出するならつけましょう。基本、速くなります。
  - メモリ使うのかな？
- [ジェネレータ](https://github.com/cheran-senthil/PyRival/blob/master/pyrival/misc/bootstrap.py)
  - 基本、速くなります。というか、遅くなった例を1件しか知りません。
    - `PyPyjit` より速く、スタック非再帰よりは遅いイメージです。
  - 書き換えるのがやや面倒ですが、 `PyPy` -> `C++` などと比べると圧倒的に楽です。
    - 関数の途中で `return` ができない点だけかな。 `if-else` で頑張ります。
  - なんで皆使ってないのか、正直謎に思ってます。
    - ホント謎です。
  - 私はこれを使うことが多いです。

こどふぉでは

- `sys.setlimitrecursion(2*10**5)` をすると `MLE`
- しないと `RE`

となるため、再帰をしてはいけないことが知られています。

### メモ化

- `functools.lru_cache` は内部で辞書を使っています。配列作って自力で書いた方が速い場合が多いです。
- LRUキャッシュを必要とせず、全てのキャッシュを普通に使う場合は、`lru_cache()` では `maxsize=None` とするとよいでしょう。

## `DataStructures`

### 順序付き集合

`PyPy` の標準ライブラリに順序付き集合はありません。代替手段を考えます。

- `sortedcontainers`
  - 言語アップデートを介して導入されました。速いかは分かってないです。
- 平方分割木(tatyam木)
  - tatyam氏の [`SortedSet/Multiset`](https://github.com/tatyam-prime/SortedSet) です。
  - `O(√N)` ですが、コードが短くわりと速いです。おそらく多くの人が使っていると思います。
  - 要素を全部削除、その後全部挿入などするととても遅いです。平衡二分木の方が速いまであります。
- 平衡二分木
  - 強いです。平方分割木と比べると遅いケースが目立ちます。
- B木
  - `k` 番目の値は遅めです。
  - `Set` はまずまずの速度です。
  - `Multiset` はまだ実装してません。
- BIT/セグ木
  - 空間 `Θ(U)` かかる点には注意です。
  - (BIT/セグ木に限らず、)座圧できるものに限られるので汎用性は低いです。
  - しかし、速いです。
- `BinaryTrie`
  - 全体 xor ができます。
  - 実装が簡易(かもしれない)です。
- 32分木
  - neighbor query に関しては最強です。
  - 空間 `Θ(U)` 、昇順 `k` 番目の値に `Θ(klogU)` かかる点には注意です。
- 亜種たち
  - `van emde boas tree` は実装次第ではとても遅いです。自分は速い実装が分かりません。
  - 追加 / 削除 を `O(√U)` として `k` 番目取得を `O(1)` でするようにすると、`Mo's Algorithm` で強いです。

## Graph

- 基本的に隣接リスト `[[] for _ in range(|V|)]` で問題ないと思います。
- グラフライブラリを作るのもよいでしょう。

## Math

- `ModInt` はとにかく遅いです。使わない方が吉です。
